import React, { memo } from 'react';
import { TextElement } from '../types/bookTypes';
import { FlatTextElement } from './ClickableBooks/BookTextFlattener';
import { safeSplitText } from './ClickableBooks/textUtils';
import classes from './ClickableSimpleBooks.module.css';

interface VirtualizedTextElementProps {
  item: FlatTextElement;
  index: number;
  textType: string;
  selectedWord: string;
  hoveredWord: string | null;
  onWordClick: (word: string, element: HTMLElement) => void;
  onHoverStart: (word: string) => void;
  onHoverEnd: () => void;
}

// Helper function to check if a text line is just a separator
const isSeparatorOnlyLine = (text: string) => {
  const trimmed = text.trim();
  return trimmed === '||' || trimmed === '//' || trimmed === '*||*' || trimmed === '*//*';
};

// Function to render words within text, extracted for cleaner code organization
const renderTextSegments = (
  text: string, 
  isTranslation: boolean,
  selectedWord: string,
  hoveredWord: string | null,
  onWordClick: (word: string, element: HTMLElement) => void,
  onHoverStart: (word: string) => void,
  onHoverEnd: () => void
) => {
  if (isSeparatorOnlyLine(text)) {
    return null;
  }

  const transformedText = isTranslation 
    ? text
    : text
        .replace(/([A-Za-z]+)_(\d+\.\d+)\s/g, '$2 ')
        .replace(/([A-Za-z]+)_(\d+)/g, '$2 ')
        .replace(/\//g, '|')
        .replace(/\.(?!\d)/g, '|')
        .replace(/\*/g, '');

  const segments = safeSplitText(transformedText);

  return segments.map((segment, segmentIndex) => {
    if (isTranslation) {
      // Handle translation with <s> tags
      const parts = segment.split(/(<s>.*?<\/s>)/);
      
      return (
        <span key={segmentIndex} className={classes.textSegment}>
          <span className={classes.textContent}>
            {parts.map((part, partIndex) => {
              if (part.startsWith('<s>') && part.endsWith('</s>')) {
                const sanskritWord = part.replace(/<\/?s>/g, '').trim();
                return (
                  <span
                    key={`${segmentIndex}-${partIndex}`}
                    onClick={(e) => onWordClick(sanskritWord.toLowerCase(), e.currentTarget)}
                    onMouseEnter={() => onHoverStart(sanskritWord)}
                    onMouseLeave={onHoverEnd}
                    className={`
                      ${classes.word}
                      ${classes.sanskritWord}
                      ${selectedWord === sanskritWord ? classes.selectedWord : ''}   
                      ${hoveredWord === sanskritWord ? classes.hoveredWord : ''}
                    `}
                  >
                    {sanskritWord + ' '}
                  </span>
                );
              }
              return <span key={`${segmentIndex}-${partIndex}`}>{part}</span>;
            })}
            {segmentIndex < segments.length - 1 && (
              <span className={classes.pipeMark}>|</span>
            )}
          </span>
          {segmentIndex < segments.length - 1 && <br />}
        </span>
      );
    } else {
      // Handle regular text
      const words = segment.split(/\s+|\+/);
      
      return (
        <span key={segmentIndex} className={classes.textSegment}>
          <span className={classes.textContent}>
            {words.map((word: string, wordIndex: number) => {
              const trimmedWord = word.trim();
              if (!trimmedWord) return null;
              
              return (
                <span
                  key={`${segmentIndex}-${wordIndex}`}
                  onClick={(e) => onWordClick(trimmedWord, e.currentTarget)}
                  onMouseEnter={() => onHoverStart(trimmedWord)}
                  onMouseLeave={onHoverEnd}
                  className={`
                    ${classes.word}
                    ${selectedWord === trimmedWord ? classes.selectedWord : ''}
                    ${hoveredWord === trimmedWord ? classes.hoveredWord : ''}
                  `}
                >
                  {word + ' '}
                </span>
              );
            })}
            {segmentIndex < segments.length - 1 && (
              <span className={classes.pipeMark}>|</span>
            )}
          </span>
          {segmentIndex < segments.length - 1 && <br />}
        </span>
      );
    }
  });
};

// The main virtualized text element component, memoized for performance
const VirtualizedTextElement = memo(({
  item,
  index,
  textType,
  selectedWord,
  hoveredWord,
  onWordClick,
  onHoverStart,
  onHoverEnd
}: VirtualizedTextElementProps) => {
  const element = item.element;
  
  return (
    <div 
      className={`${classes.paragraphContainer} ${item.parentClasses}`}
      style={{ paddingLeft: `${item.level * 1}rem` }}
      data-index={index}
    >
      {element.text && (
        <div className={`${classes.lineContainer} ${
          textType === 'or' ? classes.originalOnly : 
          textType === 'tran' ? classes.translationOnly : ''
        }`}>
          {/* Original text */}
          {(textType === 'both' || textType === 'or') && (
            <div className={classes.originalText}>
              {renderTextSegments(
                element.text, 
                false, 
                selectedWord, 
                hoveredWord, 
                onWordClick,
                onHoverStart,
                onHoverEnd
              )}
            </div>
          )}
          
          {/* Translation text */}
          {element.translated_text && (textType === 'both' || textType === 'tran') && (
            <div className={`${classes.translatedText} ${
              textType === 'tran' ? classes.translationOnly : ''
            }`}>
              {renderTextSegments(
                element.translated_text, 
                true, 
                selectedWord, 
                hoveredWord, 
                onWordClick,
                onHoverStart,
                onHoverEnd
              )}
            </div>
          )}
        </div>
      )}
    </div>
  );
}, (prevProps, nextProps) => {
  // Custom comparison function for memoization
  return (
    prevProps.index === nextProps.index &&
    prevProps.textType === nextProps.textType &&
    prevProps.selectedWord === nextProps.selectedWord &&
    prevProps.hoveredWord === nextProps.hoveredWord
  );
});

export default VirtualizedTextElement;